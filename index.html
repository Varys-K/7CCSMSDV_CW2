<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<style>

    .link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
    }

    .node {
        cursor: pointer;
    }

    .node circle {
        fill: #666;
        stroke: #142733;
        stroke-width: 3px;
    }


    .node text {
        font: 12px sans-serif;
    }

    text {
        font: 10px sans-serif;
        pointer-events: none;
    }

</style>
<head>
    <title> 1909300: Graph Similarity Computation </title>
</head>
<body>
<h1>1909300: Graph Similarity Computation</h1>
<h2>1. Introdution</h2>
<p>
    Graph is a common data structure with strong expressive power, so it is used frequently to display relationships and represent concepts.
    In practice, nodes are usually used to represent objects, and edges are often used to represent the relationship between objects.
    Among all graph researches, graph similarity analysis has been one of the most important technologies for many domains such as recommender systems, social networks, biology, and linguistics.
    Graph embeddings are the transformation of property graphs to a vector or a set of vectors.
    DeepWalk is a popular algorithm that is used to create graph embeddings and can be used to measure the node similarity based on Word2Vec algorithm in NLP.
    Similar nodes should have close embeddings.
    In this coursework, I improve the DeepWalk algorithm so that it can compute similarity score between two graphs.
</p>

<h2>2. Algorithm Design</h2>
<h3>2.1 Data Display</h3>
<p id = "first">
    This project uses data from open-source AIDS dataset from paper[1] in Github.Here is what the graphs in AIDS databases look like.
</p>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
    // http://blog.thomsonreuters.com/index.php/mobile-patent-suits-graphic-of-the-day/
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "0", target: "2", type: "licensing"},
        {source: "3", target: "2", type: "suit"},
        {source: "3", target: "5", type: "suit"},
        {source: "3", target: "6", type: "resolved"},
        {source: "2", target: "4", type: "suit"},
        {source: "4", target: "7", type: "suit"},
        {source: "7", target: "9", type: "suit"},
        {source: "6", target: "9", type: "suit"},
        {source: "6", target: "8", type: "suit"},
        {source: "11", target: "10", type: "suit"},
        {source: "11", target: "13", type: "suit"},
        {source: "11", target: "15", type: "resolved"},
        {source: "11", target: "14", type: "resolved"},
        {source: "10", target: "12", type: "suit"},
        {source: "12", target: "17", type: "suit"},
        {source: "12", target: "16", type: "resolved"},
        {source: "111", target: "100", type: "resolved"},
        {source: "22", target: "100", type: "resolved"},
        {source: "33", target: "100", type: "suit"},
        {source: "44", target: "100", type: "suit"},
        {source: "55", target: "100", type: "suit"},
        {source: "66", target: "100", type: "suit"},
        {source: "1111", target: "1000", type: "suit"},
        {source: "1111", target: "5555", type: "resolved"},
        {source: "1111", target: "4444", type: "suit"},
        {source: "1000", target: "3333", type: "suit"},
        {source: "1000", target: "2222", type: "suit"},
        {source: "3333", target: "7777", type: "suit"},
        {source: "2222", target: "6666", type: "suit"},
        {source: "5555", target: "6666", type: "suit"},
        {source: "4444", target: "7777", type: "suit"}
    ];

    var nodes = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
        link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
    });

    var width = 960,
        height = 550;

    var force = d3.layout.force()
        .nodes(d3.values(nodes))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg = d3.select("#first").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link = svg.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node = svg.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node.append("circle")
        .attr("r", 8);

    node.append("text")
        .attr("x", 12)
        .attr("dy", ".35em");
    // .text(function(d) { return d.name; });

    function tick() {
        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }
</script>

<h3>2.2 Algorithm Work Flow</h3>
<p id = "second">
    The process is as follows.
</p>
<script>
    var treeData = [
        {
            "name": "Algorithm",
            "parent": "null",
            "children": [
                {
                    "name": "DeepWalk",
                    "parent": "Algorithm",
                    "children": [
                        {
                            "name": "Random Walk",
                            "parent": "DeepWalk"
                        },
                        {
                            "name": "Word2Vec",
                            "parent": "DeepWalk",
                            "children": [
                                {
                                    "name": "SkipGram Algorithm",
                                    "parent": "Word2Vec"
                                },
                                {
                                    "name": "Embedding Dimension",
                                    "parent": "Word2Vec"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "PCA",
                    "parent": "Top Level",
                },
                {
                    "name": "Matrix Similarity Computation",
                    "parent": "Algorithm"
                }
            ]
        }
    ];


    // ************** Generate the tree diagram	 *****************
    var margin = {top: 20, right: 120, bottom: 20, left: 120},
        width = 960 - margin.right - margin.left,
        height = 500 - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root;

    var tree = d3.layout.tree()
        .size([height, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("#second").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    root = treeData[0];
    root.x0 = height / 2;
    root.y0 = 0;

    update(root);

    d3.select(self.frameElement).style("height", "500px");

    function update(source) {

        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
            links = tree.links(nodes);

        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodes…
        var node = svg.selectAll("g.node")
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click);

        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter.append("text")
            .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate.select("circle")
            .attr("r", 10)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit.select("circle")
            .attr("r", 1e-6);

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);

        // Update the links…
        var link = svg.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            });

        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();

        // Stash the old positions for transition.
        nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function click(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
    }

</script>

<h4>2.2.1 DeepWalk</h4>
<h5>(1) Random Walk</h5>
<p id = "third">
    A random walk starts in a chosen node and then moves to random neighbor from the current node for a defined number of steps.
    For example, here is the result of performing 1 time random walk of length 10 on node 1 in my example graph presented as follows.

</p>
<script>
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "0", target: "2", type: "licensing"},
        {source: "3", target: "2", type: "suit"},
        {source: "3", target: "5", type: "suit"},
        {source: "3", target: "6", type: "resolved"},
        {source: "2", target: "4", type: "suit"},
        {source: "4", target: "7", type: "suit"},
        {source: "7", target: "9", type: "suit"},
        {source: "6", target: "9", type: "suit"},
        {source: "6", target: "8", type: "suit"}
    ];

    var nodes1 = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes1[link.source] || (nodes1[link.source] = {name: link.source});
        link.target = nodes1[link.target] || (nodes1[link.target] = {name: link.target});
    });

    var width = 960,
        height = 300;

    var force = d3.layout.force()
        .nodes(d3.values(nodes1))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg2 = d3.select("#third").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link1 = svg2.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node1 = svg2.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node1.append("circle")
        .attr("r", 8);

    node1.append("text")
        .attr("x", 12)
        .attr("dy", ".35em")
        .text(function(d) { return d.name; });

    function tick() {
        link1
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node1
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }

</script>
<p id = "forth">
</p>
<script>
    var treeData = [
        {
            "name": "1",
            "parent": "null",
            "children": [
                {
                    "name": "0",
                    "parent": "1",
                    "children": [
                        {
                            "name": "2",
                            "parent": "0",
                            "children": [
                                {
                                    "name": "3",
                                    "parent": "2",
                                    "children": [
                                        {
                                            "name": "5",
                                            "parent": "3",
                                            "children": [
                                                {
                                                    "name": "3",
                                                    "parent": "5",
                                                    "children": [
                                                        {
                                                            "name": "2",
                                                            "parent": "3",
                                                            "children": [
                                                                {
                                                                    "name": "0",
                                                                    "parent": "2",
                                                                    "children": [
                                                                        {
                                                                            "name": "1",
                                                                            "parent": "0",
                                                                            "children": [
                                                                                {
                                                                                    "name": "0",
                                                                                    "parent": "1",
                                                                                    "children": [
                                                                                        {
                                                                                            "name": "1",
                                                                                            "parent": "0"
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            ]
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];


    // ************** Generate the tree diagram	 *****************
    var margin = {top: 100, right: 50, bottom: 100, left: 50},
        width = 960 - margin.right - margin.left,
        height = 200 - margin.top - margin.bottom;


    var i = 0,
        duration = 750,
        root;

    var tree = d3.layout.tree()
        .size([height, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg3 = d3.select("#forth").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    root = treeData[0];
    root.x0 = height / 2;
    root.y0 = 0;

    update(root);

    d3.select(self.frameElement).style("height", "500px");

    function update(source) {

        // Compute the new tree layout.
        var nodes11 = tree.nodes(root).reverse(),
            links = tree.links(nodes11);

        // Normalize for fixed-depth.
        nodes11.forEach(function(d) { d.y = d.depth * 80; });

        // Update the nodes…
        var node22 = svg3.selectAll("g.node")
            .data(nodes11, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node22.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click);

        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter.append("text")
            .attr("x", function(d) { return d.children || d._children ? +3 : 0; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node22.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate.select("circle")
            .attr("r", 15)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate.select("text")
            .style("fill-opacity", 2);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node22.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit.select("circle")
            .attr("r", 1e-6);

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);

        // Update the links…
        var link = svg3.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            });

        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();

        // Stash the old positions for transition.
        nodes11.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function click(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
    }

</script>


<h5>(2) Word2vec</h5>
<p>
    Training skip-gram: Random walks are comparable to sentences in word2vec approach.
    The skip-gram network accepts a node from the random walk as a one-hot vector as an input and maximizes the probability for predicting neighbor nodes.
    Computing embeddings: Embedding is the output of a hidden layer of the network.
    The DeepWalk computes embedding for each node in the graph[3].
</p>

<h4>2.2.2 PCA</h4>
<p>
    We will get a feature matrix combined with node vectors for each graph after Word1Vec step.
    But the matrix is high-dimensional, so I use PCA algorithm to keep the main features and finally get a low-dimensional matrix.
</p>



<h4>2.2.3 Matrix Similarity Computation</h4>
<p>
    At last, I turn matrixs into vectors and use cosine similarity index to measure the similarity score between graphs.
    The score is between 0 and 1. The closer to 1 means higher similarity between two graphs.
</p>




<h2>3. Results Visualization and Analyse</h2>
Summarize the main results of the project.
<h1><u>Graph Similarity Computation <span style="color: #F0E5DE">My Algorithm Results</span> and <span style="color: #ABD0CE">Graph Edit Distance Results</span></u></h1>
<div id="table"></div>
<script type="text/javascript">
    d3.csv("./data/all_data.csv", function (error, data){ //Loading csv file
        if (error){                                            //Handling errors
            console.log("An error occured while loading data");
        }

        var myArray = [];

        data.forEach(function(d, i){
            myArray.push([d.Image_No1, d.My_Algorithm, d.Image_No2, d.Graph_Edit_Distance]) //Now this is an array of arrays
        });                                                                      //Not an array of objects
        console.log("New data: ", myArray);


        /*
        myArray.sort(function(a,b){                 //This will sort data by % difference
            return d3.ascending(a[3], b[3]);         //in descending order
        })
        */

        var table = d3.select("#table").append("table");                        //Adding table to an element
        var header = table.append("thead").append("tr");                         //Adding heads row

        header
            .selectAll("th")
            .data(["Image No", "My Algorithm", "Image No", "Graph Edit Distance"])           //Header names slightly different
            .enter()                                                             //to initial
            .append("th")
            .text(function(d){
                return d;
            })

        var tBody = table.append("tbody");

        var rows = tBody
            .selectAll("tr")
            .data(myArray).enter()
            .append("tr")
            .on("mouseover", function(){
                d3.select(this)
                    .style("background-color", "#e5d9c9")
            })
            .on("mouseout", function (){
                d3.select(this)
                    .style("background-color", "white")
            });

        var cells = rows
            .selectAll("td")
            .data(function(d){
                return d;
            })
            .enter()
            .append("td")
            .text(function(d){
                return d;
            })


    })
</script>

<h2>4. Conclusion</h2>
provide a reflection of your work, what you would do differently, what could be done further.

<h2>5. Reference</h2>
[1] Bai, Yunsheng & Ding, Hao & Bian, Song & Chen, Ting & Sun, Yizhou & Wang, Wei. (2019). SimGNN: A Neural Network Approach to Fast Graph Similarity Computation. WSDM '19: Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining. 384-392. 10.1145/3289600.3290967.
[2]
[3] https://towardsdatascience.com/graph-embeddings-the-summary-cc6075aba007


</body>
</html>


