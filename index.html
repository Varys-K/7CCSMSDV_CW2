---
layout: default
---
<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<style>

    .link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
    }

    .node {
        cursor: pointer;
    }

    .node circle {
        fill: #666;
        stroke: #142733;
        stroke-width: 3px;
    }


    .node text {
        font: 12px sans-serif;
    }

    text {
        font: 10px sans-serif;
        pointer-events: none;
    }

</style>
<head>
    <title> 1909300: Graph Similarity Computation </title>
</head>
<body>
<h1>1909300: Graph Similarity Computation</h1>
<h2>1. Introdution</h2>
<p>
    Graph is a common data structure with strong expressive power, so it is used frequently to display relationships and represent concepts.
    In practice, nodes are usually used to represent objects, and edges are often used to represent the relationship between objects.
    Among all graph researches, graph similarity analysis has been one of the most important technologies for many domains such as recommender systems, social networks, biology, and linguistics.
    Graph embeddings are the transformation of property graphs to a vector or a set of vectors.
    DeepWalk is a popular algorithm that is used to create graph embeddings and can be used to measure the node similarity based on Word2Vec algorithm in NLP.
    Similar nodes should have close embeddings.
    In this coursework, I improve the DeepWalk algorithm so that it can compute similarity score between two graphs.
</p>

<h2>2. Algorithm Design</h2>
<h3>2.1 Data Display</h3>
<p id = "first">
    This project uses data from open-source AIDS dataset from paper[1] in Github.
    Here is what the graphs in AIDS databases look like.
    In my project, I select 559 of them to test my algorithm.
</p>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
    // http://blog.thomsonreuters.com/index.php/mobile-patent-suits-graphic-of-the-day/
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "0", target: "2", type: "licensing"},
        {source: "3", target: "2", type: "suit"},
        {source: "3", target: "5", type: "suit"},
        {source: "3", target: "6", type: "resolved"},
        {source: "2", target: "4", type: "suit"},
        {source: "4", target: "7", type: "suit"},
        {source: "7", target: "9", type: "suit"},
        {source: "6", target: "9", type: "suit"},
        {source: "6", target: "8", type: "suit"},
        {source: "11", target: "10", type: "suit"},
        {source: "11", target: "13", type: "suit"},
        {source: "11", target: "15", type: "resolved"},
        {source: "11", target: "14", type: "resolved"},
        {source: "10", target: "12", type: "suit"},
        {source: "12", target: "17", type: "suit"},
        {source: "12", target: "16", type: "resolved"},
        {source: "111", target: "100", type: "resolved"},
        {source: "22", target: "100", type: "resolved"},
        {source: "33", target: "100", type: "suit"},
        {source: "44", target: "100", type: "suit"},
        {source: "55", target: "100", type: "suit"},
        {source: "66", target: "100", type: "suit"},
        {source: "1111", target: "1000", type: "suit"},
        {source: "1111", target: "5555", type: "resolved"},
        {source: "1111", target: "4444", type: "suit"},
        {source: "1000", target: "3333", type: "suit"},
        {source: "1000", target: "2222", type: "suit"},
        {source: "3333", target: "7777", type: "suit"},
        {source: "2222", target: "6666", type: "suit"},
        {source: "5555", target: "6666", type: "suit"},
        {source: "4444", target: "7777", type: "suit"}
    ];

    var nodes = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
        link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
    });

    var width = 960,
        height = 550;

    var force = d3.layout.force()
        .nodes(d3.values(nodes))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg = d3.select("#first").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link = svg.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node = svg.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node.append("circle")
        .attr("r", 8);

    node.append("text")
        .attr("x", 12)
        .attr("dy", ".35em");
    // .text(function(d) { return d.name; });

    function tick() {
        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }
</script>

<h3>2.2 Algorithm Work Flow</h3>
<p id = "second">
    The process is as follows.
</p>
<script>

    var treeData1 = [
        {
            "name": "Algorithm",
            "parent": "null",
            "children": [
                {
                    "name": "Deep Walk",
                    "parent": "Algorithm",
                    "children": [
                        {
                            "name": "Random Walk",
                            "parent": "Deep Walk"
                        },
                        {
                            "name": "Word2Vec",
                            "parent": "Deep Walk",
                            "children": [
                                {
                                    "name": "SkipGram Algorithm",
                                    "parent": "Word2Vec"
                                },
                                {
                                    "name": "Embedding Dimension Matrix",
                                    "parent": "Word2Vec"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "PCA",
                    "parent": "Top Level",
                },
                {
                    "name": "Matrix Similarity Computation",
                    "parent": "Algorithm"
                }
            ]
        }
    ];


    // ************** Generate the tree diagram	 *****************
    var margin = {top: 20, right: 50, bottom: 20, left: 120},
        width = 960 - margin.right - margin.left,
        height = 500 - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root1;

    var tree1 = d3.layout.tree()
        .size([height, width]);

    var diagonal5 = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg5 = d3.select("#second").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    root1 = treeData1[0];
    root1.x0 = height / 2;
    root1.y0 = 0;

    update1(root1);

    d3.select(self.frameElement).style("height", "500px");

    function update1(source) {

        // Compute the new tree layout.
        var nodes5 = tree1.nodes(root1).reverse(),
            links5 = tree1.links(nodes5);

        // Normalize for fixed-depth.
        nodes5.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodesâ€¦
        var node5 = svg5.selectAll("g.node")
            .data(nodes5, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter5 = node5.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click1);

        nodeEnter5.append("circle")
            .attr("r", 1e-6)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter5.append("text")
            .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate5 = node5.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate5.select("circle")
            .attr("r", 10)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate5.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit5 = node5.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit5.select("circle")
            .attr("r", 1e-6);

        nodeExit5.select("text")
            .style("fill-opacity", 1e-6);

        // Update the linksâ€¦
        var link5 = svg5.selectAll("path.link")
            .data(links5, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link5.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal5({source: o, target: o});
            });

        // Transition links to their new position.
        link5.transition()
            .duration(duration)
            .attr("d", diagonal5);

        // Transition exiting nodes to the parent's new position.
        link5.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal5({source: o, target: o});
            })
            .remove();

        // Stash the old positions for transition.
        nodes5.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function click1(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update1(d);
    }

</script>

<h4>2.2.1 DeepWalk</h4>
<h5>(1) Random Walk</h5>
<p id = "third">
    A random walk starts in a chosen node and then moves to random neighbor from the current node for a defined number of steps.
    For example, here is the result of performing 1 time random walk of length 10 on node 1 in my example graph presented as follows.

</p>
<script>
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "0", target: "2", type: "licensing"},
        {source: "3", target: "2", type: "suit"},
        {source: "3", target: "5", type: "suit"},
        {source: "3", target: "6", type: "resolved"},
        {source: "2", target: "4", type: "suit"},
        {source: "4", target: "7", type: "suit"},
        {source: "7", target: "9", type: "suit"},
        {source: "6", target: "9", type: "suit"},
        {source: "6", target: "8", type: "suit"}
    ];

    var nodes1 = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes1[link.source] || (nodes1[link.source] = {name: link.source});
        link.target = nodes1[link.target] || (nodes1[link.target] = {name: link.target});
    });

    var width = 960,
        height = 300;

    var force = d3.layout.force()
        .nodes(d3.values(nodes1))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg2 = d3.select("#third").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link1 = svg2.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node1 = svg2.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node1.append("circle")
        .attr("r", 8);

    node1.append("text")
        .attr("x", 12)
        .attr("dy", ".35em")
        .text(function(d) { return d.name; });

    function tick() {
        link1
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node1
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }

</script>
<p id = "forth">
</p>
<script>
    var treeData = [
        {
            "name": "1",
            "parent": "null",
            "children": [
                {
                    "name": "0",
                    "parent": "1",
                    "children": [
                        {
                            "name": "2",
                            "parent": "0",
                            "children": [
                                {
                                    "name": "3",
                                    "parent": "2",
                                    "children": [
                                        {
                                            "name": "5",
                                            "parent": "3",
                                            "children": [
                                                {
                                                    "name": "3",
                                                    "parent": "5",
                                                    "children": [
                                                        {
                                                            "name": "2",
                                                            "parent": "3",
                                                            "children": [
                                                                {
                                                                    "name": "0",
                                                                    "parent": "2",
                                                                    "children": [
                                                                        {
                                                                            "name": "1",
                                                                            "parent": "0",
                                                                            "children": [
                                                                                {
                                                                                    "name": "0",
                                                                                    "parent": "1",
                                                                                    "children": [
                                                                                        {
                                                                                            "name": "1",
                                                                                            "parent": "0"
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            ]
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];


    // ************** Generate the tree diagram	 *****************
    var margin = {top: 100, right: 20, bottom: 100, left: 20},
        width = 960 - margin.right - margin.left,
        height = 200 - margin.top - margin.bottom;


    var i = 0,
        duration = 750,
        root;

    var tree = d3.layout.tree()
        .size([height, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg3 = d3.select("#forth").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    root = treeData[0];
    root.x0 = height / 2;
    root.y0 = 0;

    update(root);

    d3.select(self.frameElement).style("height", "500px");

    function update(source) {

        // Compute the new tree layout.
        var nodes11 = tree.nodes(root).reverse(),
            links = tree.links(nodes11);

        // Normalize for fixed-depth.
        nodes11.forEach(function(d) { d.y = d.depth * 80; });

        // Update the nodesâ€¦
        var node22 = svg3.selectAll("g.node")
            .data(nodes11, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter1 = node22.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("click", click);

        nodeEnter1.append("circle")
            .attr("r", 1e-6)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter1.append("text")
            .attr("x", function(d) { return d.children || d._children ? +3 : 0; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate1 = node22.transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate1.select("circle")
            .attr("r", 15)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate1.select("text")
            .style("fill-opacity", 2);

        // Transition exiting nodes to the parent's new position.
        var nodeExit2 = node22.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit2.select("circle")
            .attr("r", 1e-6);

        nodeExit2.select("text")
            .style("fill-opacity", 1e-6);

        // Update the linksâ€¦
        var link3 = svg3.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link3.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            });

        // Transition links to their new position.
        link3.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link3.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();

        // Stash the old positions for transition.
        nodes11.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function click(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
    }

</script>


<h5>(2) Word2vec</h5>
<p>
    Training skip-gram: Random walks are comparable to sentences in word2vec approach.
    The skip-gram network accepts a node from the random walk as a one-hot vector as an input and maximizes the probability for predicting neighbor nodes.<br />
    Computing embeddings: Embedding is the output of a hidden layer of the network.
    The DeepWalk computes embedding for each node in the graph[3].
</p>

<h4>2.2.2 PCA</h4>
<p>
    We will get a feature matrix combined with node vectors for each graph after Word1Vec step.
    But the matrix is high-dimensional, so I use PCA algorithm to keep the main features and finally get a low-dimensional matrix.
</p>



<h4>2.2.3 Matrix Similarity Computation</h4>
<p>
    At last, I turn matrixs into vectors and use cosine similarity index to measure the similarity score between graphs.
    The score is between 0 and 1. The closer to 1 means higher similarity between two graphs.
</p>




<h2>3. Results Visualization and Analyse</h2>

<p>
    Graph Edit Distance(GED) is one of the best methods to measure graph similarity,
    but it can not measure structure similarity well which is what my algorithm intends to do.
    But when two graphs are exactly the same, GED will be 0, and it can be use to test whether my algorithm
    is able to find all identical graphs.
    The result is shown in the following table. The table shows top 10 similar graphs with graph 3 which are in in descending order.
    From the table, we can see my algorithm can effectively recognizes identical graphs.
</p>

<h3><u>Graph Similarity Computation <span style="color: #F0E5DE">My Algorithm Results</span> and <span style="color: #ABD0CE">Graph Edit Distance Results</span></u></h3>
<div id="table"></div>
<script type="text/javascript">
    d3.csv("./data/all_data.csv", function (error, data){ //Loading csv file
        if (error){                                            //Handling errors
            console.log("An error occured while loading data");
        }

        var myArray = [];

        data.forEach(function(d, i){
            myArray.push([d.Image_No1, d.My_Algorithm, d.Image_No2, d.Graph_Edit_Distance]) //Now this is an array of arrays
        });                                                                      //Not an array of objects
        console.log("New data: ", myArray);


        /*
        myArray.sort(function(a,b){                 //This will sort data by % difference
            return d3.ascending(a[3], b[3]);         //in descending order
        })
        */

        var table = d3.select("#table").append("table");                        //Adding table to an element
        var header = table.append("thead").append("tr");                         //Adding heads row

        header
            .selectAll("th")
            .data(["Image No", "My Algorithm", "Image No", "Graph Edit Distance"])           //Header names slightly different
            .enter()                                                             //to initial
            .append("th")
            .text(function(d){
                return d;
            })

        var tBody = table.append("tbody");

        var rows = tBody
            .selectAll("tr")
            .data(myArray).enter()
            .append("tr")
            .on("mouseover", function(){
                d3.select(this)
                    .style("background-color", "#e5d9c9")
            })
            .on("mouseout", function (){
                d3.select(this)
                    .style("background-color", "white")
            });

        var cells = rows
            .selectAll("td")
            .data(function(d){
                return d;
            })
            .enter()
            .append("td")
            .text(function(d){
                return d;
            })


    })
</script>

In more details, in the following, I will only show No 5 to 10 graphs in the above table since top 4 graphs have identical structure.
The whole results and other test data can be found in my Github.
<p id = "sixth">
    This is what graph 3 looks like.
</p>
<p id = "seventh">
    <style>
        .node12 circle {
            fill: #B0C4DE;
            stroke: #B0C4DE;
            stroke-width: 3px;
        }
    </style>
    And these are the graphs that my algorithm found of highest similarity score with graph 3 among all 558 graphs in the databases.

</p>
<p id = "eighth">
    This is what GED algorithm found that have minimal graph edit distances.
    <style>
        .node1 circle {
            fill: #336600;
            stroke: #336600;
            stroke-width: 3px;
        }
    </style>
</p>
<script>
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "1", target: "3", type: "licensing"},
        {source: "1", target: "5", type: "suit"},
        {source: "1", target: "4", type: "suit"},
        {source: "0", target: "2", type: "resolved"},
        {source: "2", target: "6", type: "suit"},
        {source: "2", target: "7", type: "suit"}
    ];

    var nodes1 = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes1[link.source] || (nodes1[link.source] = {name: link.source});
        link.target = nodes1[link.target] || (nodes1[link.target] = {name: link.target});
    });

    var width = 960,
        height = 300;

    var force = d3.layout.force()
        .nodes(d3.values(nodes1))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg55 = d3.select("#sixth").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link55 = svg55.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node55 = svg55.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node55.append("circle")
        .attr("r", 8);

    node55.append("text")
        .attr("x", 12)
        .attr("dy", ".35em")
    //.text(function(d) { return d.name; });

    function tick() {
        link55
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node55
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }

</script>
<script>
    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "1", target: "3", type: "licensing"},
        {source: "1", target: "5", type: "suit"},
        {source: "1", target: "4", type: "suit"},
        {source: "0", target: "2", type: "resolved"},
        {source: "2", target: "7", type: "suit"},
        {source: "7", target: "6", type: "suit"},
        {source: "11", target: "10", type: "licensing"},
        {source: "11", target: "13", type: "licensing"},
        {source: "11", target: "15", type: "suit"},
        {source: "11", target: "14", type: "suit"},
        {source: "10", target: "12", type: "resolved"},
        {source: "12", target: "16", type: "licensing"},
        {source: "17", target: "16", type: "licensing"},
        {source: "110", target: "100", type: "licensing"},
        {source: "110", target: "130", type: "licensing"},
        {source: "110", target: "150", type: "suit"},
        {source: "110", target: "140", type: "suit"},
        {source: "100", target: "120", type: "resolved"},
        {source: "120", target: "160", type: "licensing"},
        {source: "170", target: "160", type: "licensing"},
        {source: "1100", target: "1000", type: "licensing"},
        {source: "1100", target: "1300", type: "licensing"},
        {source: "1100", target: "1500", type: "suit"},
        {source: "1100", target: "1400", type: "suit"},
        {source: "1000", target: "1200", type: "resolved"},
        {source: "1200", target: "1600", type: "licensing"},
        {source: "1700", target: "1600", type: "licensing"},
        {source: "1101", target: "1001", type: "licensing"},
        {source: "1101", target: "1301", type: "licensing"},
        {source: "1101", target: "1501", type: "suit"},
        {source: "1101", target: "1401", type: "suit"},
        {source: "1001", target: "1201", type: "resolved"},
        {source: "1201", target: "1601", type: "licensing"},

        {source: "111", target: "11011", type: "resolved"},
        {source: "111", target: "113", type: "licensing"},
        {source: "111", target: "115", type: "licensing"},
        {source: "111", target: "114", type: "licensing"},
        {source: "11011", target: "112", type: "licensing"},
        {source: "112", target: "116", type: "suit"},
        {source: "117", target: "116", type: "suit"},
        {source: "116", target: "118", type: "resolved"}
    ];

    var nodes1 = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes1[link.source] || (nodes1[link.source] = {name: link.source});
        link.target = nodes1[link.target] || (nodes1[link.target] = {name: link.target});
    });

    var width = 960,
        height = 600;

    var force = d3.layout.force()
        .nodes(d3.values(nodes1))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg4 = d3.select("#seventh").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link4 = svg4.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node4 = svg4.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node12")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node4.append("circle")
        .attr("r", 8);

    node4.append("text")
        .attr("x", 12)
        .attr("dy", ".35em")
    //.text(function(d) { return d.name; });

    function tick() {
        link4
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node4
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }

</script>
<script>

    var links = [
        {source: "1", target: "0", type: "licensing"},
        {source: "1", target: "3", type: "licensing"},
        {source: "1", target: "2", type: "suit"},
        {source: "1", target: "4", type: "suit"},
        {source: "3", target: "5", type: "resolved"},
        {source: "5", target: "7", type: "suit"},
        {source: "5", target: "6", type: "suit"},
        {source: "4", target: "6", type: "suit"},

        {source: "11", target: "10", type: "licensing"},
        {source: "11", target: "12", type: "licensing"},
        {source: "10", target: "14", type: "suit"},
        {source: "13", target: "12", type: "suit"},
        {source: "13", target: "14", type: "resolved"},
        {source: "12", target: "15", type: "licensing"},
        {source: "12", target: "16", type: "licensing"},
        {source: "14", target: "17", type: "licensing"},

        {source: "111", target: "100", type: "licensing"},
        {source: "111", target: "103", type: "licensing"},
        {source: "111", target: "102", type: "suit"},
        {source: "111", target: "104", type: "suit"},
        {source: "103", target: "105", type: "resolved"},
        {source: "105", target: "107", type: "licensing"},
        {source: "105", target: "106", type: "licensing"},
        {source: "104", target: "106", type: "licensing"},

        {source: "1001", target: "1000", type: "licensing"},
        {source: "1001", target: "1003", type: "suit"},
        {source: "1001", target: "1005", type: "suit"},
        {source: "1001", target: "1004", type: "resolved"},
        {source: "1000", target: "1002", type: "licensing"},
        {source: "1002", target: "1007", type: "licensing"},
        {source: "1002", target: "1006", type: "licensing"},
        {source: "1006", target: "1008", type: "licensing"},

        {source: "1111", target: "1110", type: "suit"},
        {source: "1111", target: "1115", type: "suit"},
        {source: "1111", target: "1117", type: "resolved"},
        {source: "1111", target: "1116", type: "licensing"},
        {source: "1110", target: "1113", type: "resolved"},
        {source: "1110", target: "1112", type: "licensing"},
        {source: "1110", target: "1114", type: "licensing"},

        {source: "11111", target: "11110", type: "licensing"},
        {source: "11111", target: "11115", type: "licensing"},
        {source: "11111", target: "11114", type: "suit"},
        {source: "11111", target: "11116", type: "suit"},
        {source: "11110", target: "11113", type: "resolved"},
        {source: "11110", target: "11112", type: "resolved"},
        {source: "11112", target: "11117", type: "resolved"}
    ];

    var nodes1 = {};

    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
        link.source = nodes1[link.source] || (nodes1[link.source] = {name: link.source});
        link.target = nodes1[link.target] || (nodes1[link.target] = {name: link.target});
    });

    var width = 960,
        height = 600;

    var force = d3.layout.force()
        .nodes(d3.values(nodes1))
        .links(links)
        .size([width, height])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

    var svg8 = d3.select("#eighth").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link8 = svg8.selectAll(".link")
        .data(force.links())
        .enter().append("line")
        .attr("class", "link");

    var node8 = svg8.selectAll(".node")
        .data(force.nodes())
        .enter().append("g")
        .attr("class", "node1")
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .call(force.drag);

    node8.append("circle")
        .attr("r", 8);

    node8.append("text")
        .attr("x", 12)
        .attr("dy", ".35em")
    //.text(function(d) { return d.name; });

    function tick() {
        link8
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node8
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    }

    function mouseover() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 16);
    }

    function mouseout() {
        d3.select(this).select("circle").transition()
            .duration(750)
            .attr("r", 8);
    }

</script>
<p>
    In conclusion, my algorithm can effectively recognize identical graphs and can measure structure similarity well.
    In comparison, GED shows another way to define graph similarity using edit distance.
    It is interesting that my algorithm may get slightly different similarity scores for each run
    because it is based on random walk, but the result ordering sequences is stable.
    Compared to GED, my algorithm is not that precise, however, my algorithm is very fast
    and can be computed in parallel. It is known that GED is extremely slow.
</p>


<h2>4. Conclusion</h2>

To sum up, in this coursework, I design an algorithm to compute graph structure similarity scores between two undirected and unlabelled
nodes at first. And then I make several experiments to test my algorithm and compare my algorithm with GED, which shows my
algorithm is effective and efficient. But the experiment also shows that my algorithm lacks precision which can be improved in
the future. There are many aspects can be improved. For example, I can change various ways of random walks to get better structure features or I can use more complex
matrix similarity computation method to get similarity score.
<h2>5. Reference</h2>
<p>
    [1] Bai, Yunsheng & Ding, Hao & Bian, Song & Chen, Ting & Sun, Yizhou & Wang, Wei. (2019). SimGNN: A Neural Network Approach to Fast Graph Similarity Computation. WSDM '19: Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining. 384-392. 10.1145/3289600.3290967.<br />
    [2] Perozzi, Bryan & Al-Rfou, Rami & Skiena, Steven. (2014). DeepWalk: Online Learning of Social Representations. Proceedings of the ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. 10.1145/2623330.2623732.<br />
    [3] https://towardsdatascience.com/graph-embeddings-the-summary-cc6075aba007<br />
    [4] https://bl.ocks.org/d3noob/fa0f16e271cb191ae85f<br />
    [5] http://bl.ocks.org/mbostock/2706022<br />
    [6] https://gist.github.com/edkiljak/158353df457eda05d2ec4b5c3bb61660/revisions<br />
</p>

</body>
</html>
